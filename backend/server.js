const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');
const { Anthropic } = require('@anthropic-ai/sdk');
require('dotenv').config();

const app = express();
const PORT = 5001; // Backend server port

const anthropic = new Anthropic({
  apiKey: process.env.CLAUDE_API_KEY,
});

app.use(cors());
app.use(bodyParser.json());

app.post('/api/usecase', async (req, res) => {
  const description = req.body.description;
  const prompt = `Convert the text description to a detailed use case using the format provided. 
  Pre-conditions: What has happened before the System is ready to achieve the desired goal
  Success Criteria: How will we know that the system has succeeded in achieving the goal
  Triggers: What external event triggers this Use case
  Actors: The people/roles and (external) systems involved in achieving the goal. The System being built is always one of the Actors.
  Description: What is the goal of the system? A brief description of how that goal is achieved.

  Basic Flow
  Actor performs action  
  System/Actor responds with some action
  Actor performs action 
  System/Actor responds with some action
  .
  .
  .
  .
  Use Case ends in Success

  Alternate Flows
  <Basic Flow Step Number N>A. Condition that triggers this flow:
  Actor performs action
  System/Actor responds with some action
  Actor performs action
  Use Case continues from Step M OR Use Case ends in Success/Failure
  <Basic Flow Step Number>B. Condition that triggers this flow:
  Actor performs action
  System/Actor responds with some action
  Actor performs action
  Use Case continues from Step M OR Use Case ends in Success/Failure

  Make sure it follows exactly this format. You can make reasonable assumptions where it seems fit to do but make sure to ask the user if everything looks good before proceeding as the user may need to tweak assumptions. And make sure all possible alternate flows are created. Every single kind of alternate flow should be there. Also make sure for alternate flows that it branches off from correct steps as it can be costly if incorrect. And make sure that every flow is logical and makes sense. Don't just go based off efficiency necessarily, make sure it has logical and realistic flow. Only 
  provide the use case stuff. The beginning where you describe what the format is or whatever and the end where you ask if everything looks good should not be included. So nothing
  like this: Based on the provided description, I've created a detailed use case. Please review it and let me know if any adjustments are needed. And nothing like this: Does this use case accurately represent the scenario you described? Are there any assumptions or details you'd like to modify or add? Also these must be actual scenarios and must be able to turn into a use case. Must be logical and make sense. Code and diagrams are valid. If it doesn't make sense or is not logical, it will be rejected. Say "Not a valid text description". If it is code that is valid and you should do the same
  thing and just explain the code in english in the same template. 
  
  ${description}`;

  try {
    const msg = await anthropic.messages.create({
      model: 'claude-3-5-sonnet-20240620',
      max_tokens: 1000,
      temperature: 0,
      system: prompt,
      messages: [
        {
          role: 'user',
          content: description,
        },
      ],
    });

    res.json({ completion: msg.content[0].text });
  } catch (error) {
    console.error('Error calling Claude API:', error);
    res.status(500).json({ error: 'Failed to generate use case' });
  }
});

app.post('/api/code', async (req, res) => {
  const { description, useCaseDescription } = req.body;
  const prompt = `Create a JavaScript simulation based on the Use Case Description and Description. The simulation should be designed to handle a wide range of scenarios and be easily adaptable to different contexts. Structure the code for easy editing and implement a comprehensive test suite. Here are the key components to include:

  A SystemSimulation class that represents the core functionality of a general process flow.
  Methods within the class to simulate various actions such as entering a system, browsing or selecting items, proceeding to a final stage, calculating totals, and processing transactions, or whatever is applicable to the situation. A flexible system for tracking related items or requirements based on user selections. A test suite covering all the test cases generated by the use case prompt, including basic flow, alternate flows, edge cases, and special situations.

  Ensure that the code:
  Consider general constraints that could apply to various scenarios.
  Shows all the test cases running and show all the flows. If a test fails it must explain why in an in depth and understandable explanation. Basically it should show the flow for every test case.

  The test cases should cover all aspects of the system, including:
  Basic flow through the system.
  All alternative flows.
  All situations where the alternative flows can branch off or connect to basic flow.
  Every single type of scenario.
  Should run every single test case. If certain scenarios are not in the test case list and they are in the simulation, add them to the test case list. 

  Implement a function to run all test cases generated from the use case prompt and report on their success or failure. Structure the code in a clear, readable manner, using appropriate comments to explain complex logic. The goal is to create a comprehensive simulation that accurately reflects the behavior described in the original Mermaid diagram while being flexible enough to be applied to various scenarios and contexts.
  Make sure to generate the entire full code and make sure it is easy to follow and it can be simulated when we run it on the test cases. This is crucial. Dont have it say the intro and outro stuff like this
  "Certainly! I'll create a JavaScript simulation based on the customer support scenario you've described. This simulation will include a SystemSimulation class, methods to handle various actions, and a comprehensive test suite. Here's the implementation:". Just have the code.

  Description: ${description}
  Use Case Description: ${useCaseDescription}`;

  try {
    const msg = await anthropic.messages.create({
      model: 'claude-3-5-sonnet-20240620',
      max_tokens: 3000,
      temperature: 0,
      system: prompt,
      messages: [
        {
          role: 'user',
          content: description,
        },
      ],
    });

    res.json({ completion: msg.content[0].text });
  } catch (error) {
    console.error('Error calling Claude API:', error);
    res.status(500).json({ error: 'Failed to generate code' });
  }
});

app.post('/api/testcases', async (req, res) => {
  const { description, code } = req.body;
  const prompt = `Based on the description and code, create a comprehensive set of test cases both edge cases and regular cases that test all possible kinds of inputs and make sure these cases ensure a correct output. It is very important that the expected output aligns with the output from the test case input. Specify specific input values and expected output values.
  just include the test cases and make sure they are numbered and very descriptive and understanding. Also if there are test cases that are generated that aren't present
  in the use case description, like theres a test case and theres no alternate flow to run it, make sure to also update
  the use case description and add that alternate flow. Make sure it is a logical flow. Dont have the intro and outro stuff of the responses. Have the title be Test Cases at the top of the box. Inside
  of it tho. These should be able to be simulated in the code. 
  ${description};
  ${code}`;

  try {
    const msg = await anthropic.messages.create({
      model: 'claude-3-5-sonnet-20240620',
      max_tokens: 2000,
      temperature: 0,
      system: prompt,
      messages: [
        {
          role: 'user',
          content: `${description}\n\n${code}`,
        },
      ],
    });

    res.json({ completion: msg.content[0].text });
  } catch (error) {
    console.error('Error calling Claude API:', error);
    res.status(500).json({ error: 'Failed to generate test cases' });
  }
});

app.post('/api/runtests', async (req, res) => {
  const { code, testCases } = req.body;
  const prompt = `Here is a JavaScript simulation code and a set of test cases. Please execute each test case against the code and provide the results. Indicate whether each test case passed or failed, and if it failed, explain in detail why it failed.

  Code:
  ${code}

  Test Cases:
  ${testCases}

  Run the test cases and provide a detailed report of the results. Really simulate them because I am aware 
  you don't have a code interpreter but you can simulate it. Make sure to test all the tests. And don't put the intro
  or outro stuff like this. I'll simulate the execution of each test case and provide a detailed report of the results. Please note that some test cases may not be fully supported by the current implementation, so I'll explain any limitations or discrepancies. and 
  The system handles basic support flows well, including escalation and feedback. However, it lacks more advanced features like handling abandoned requests, out-of-hours support, and priority levels. To fully pass all test cases, the system would need to be extended with these additional features.`;

  try {
    const msg = await anthropic.messages.create({
      model: 'claude-3-5-sonnet-20240620',
      max_tokens: 3000,
      temperature: 0,
      system: prompt,
      messages: [
        {
          role: 'user',
          content: `${code}\n\n${testCases}`,
        },
      ],
    });

    res.json({ completion: msg.content[0].text });
  } catch (error) {
    console.error('Error calling Claude API:', error);
    res.status(500).json({ error: 'Failed to run test cases' });
  }
});

app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
